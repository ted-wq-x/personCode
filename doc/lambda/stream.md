## 为什么需要`stream`

1. 代码能够更加的清晰
2. 开发人员通过使用Stream API形式的更高层​​次的抽象来表达他们想要做什么而不是他们想要怎么做。
3. Stream API提供统一的数据处理语言。 现在开发人员在谈论数据处理时会有一个共同的词汇。 当两位开发人员谈论过滤功能时，您可以确定它们都在应用数据过滤操作。
4. 不需要样板代码来表达数据处理。开发人员不再需要编写显式的for循环，或者创建临时集合来存储数据。 Stream API自己解决。
5. stream不会改变底层的数据集合。

注：开发人员应该牢记的一件事是，Stream是一个更高级别的抽象，而不是数据结构。 Stream不存储任何数据。

## 什么时候使用`Parallel Stream`

翻译自[When to use parallel streams](http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html)

`java.util.streams`框架支持对集合和其他数据源的数据驱动操作。大多数流方法对每个数据元素执行相同的操作。当有多个可用的cpu内核时，
“数据驱动”可以通过使用集合的`parallelStream()`方法变成“数据并行”。但你什么时候应该这样做呢？

在操作独立、或者计算量很大、大量的可分割的数据结构时,考虑使用`S.parallelStream().operation(F)`而不是`S.stream().operation(F)`。

* `F`代表对每个元素独立执行的函数（通常是lambda）
* `S`高效可分割的数据源集合。除了Collections之外，还有一些其他易于并行化的流源，例如，`java.util.SplittableRandom`,但是大多数基于IO的源主要用于顺序使用。

流框架不（并且不能）强制执行任何这些。 如果计算不是独立的，那么并行运行就不会有任何意义，甚至可能是有害的。 其他标准来自三个工程问题和权衡：

启动
    
    由于处理器多年来增加了内核，大多数还增加了功能控制机制，可以使这些内核启动速度缓慢，有时会受到JVM，操作系统和虚拟机管理程序的额外开销。
    阈值大致近似于足够的核心开始处理并行子任务是值得的时间。 一旦开始，并行计算可以比顺序更高效（取决于各种处理器和系统细节;[参见Federova等人的这篇文章](http://queue.acm.org/detail.cfm?id=1658422)）。

颗粒度
    
    颗粒度太小是不值得的。框架通常存在如何分解以使得可以在系统的多个内核上处理。如果启动后每个核心几乎没有任何东西，则浪费并行计算的（大部分连续的）努力。 考虑到现在核心的实际范围从2到256，阈值也远远超过分区效应。

分割性

    高效的分割集合有`ArrayLists and {Concurrent}HashMaps`，当然还有纯数组（如使用` java.util.Arrays `的静态方法对T[]进行分割），
    最低效的是`LinkedLists, BlockingQueues`还有基于IO资源的，如果分区数据比处理数据需要更长时间，则浪费这些工作量。因此，如果计算的Q因子足够高，即使对于LinkedList
    也可能会获得平行加速，但这不是很常见。另外，一些源不能完全分解为单个元素，因此在分配任务的过程中可能存在限制。
    
仔细测量这些影响可能是困难的（尽管在一些情况下可以使用诸如JMH的工具进行）。但总体效果很容易看出。 你可以尝试一下自己的感受。 例如，
在一个32位核心的测试机器上运行函数，如在ArrayList上的max（）或sum（），break-even非常接近10K的大小。 更大的尺寸可以达到20倍以上的加速。
尺寸小于10K的运行时间并不比10K的运行时间少，因此通常比顺序慢。 当有少于100个元素时，会发生最严重的减速 - 这会激活一堆最终没有任何作用的线程，
因为计算在甚至启动之前完成。 另一方面，当每个元素的计算是耗时的时候，使用有效且完全可拆分的集合（例如ArrayList）时，效果是即时的。

所有这一切的另一种方法是，当没有足够的计算来证明它时，使用parallel（）可能会花费大约100微秒，而在合理的情况下使用它可以至少节省这么多时间
（可能是几个小时的很大的问题）。 确切的成本和收益随时间和平台而变化，并且在不同的背景下也有所不同。 例如，在顺序循环中平行运行一个微小的计算会加剧斜坡和斜坡效应。
（这样做的微型基准可能并不能预测实际的用途。）


### Some Questions and Answers

1. 为什么JVM不能自己判断是否使用并行模式？

它可以尝试，但它会给错误的答案太频繁。 过去三十年来，对完全无指导的自动多核并行性的追求并没有统一成功，所以流框架采用了更为安全的方法，
只需要用户的肯定/否决定。 这些决策依赖于不太可能完全消失的工程权衡，并且类似于连续编程中所做的那些。 例如，当只收集一个元素的集合中找到最大元素，
而不是直接使用该元素（不在集合中）时，您可能会遇到一百倍的开销（减速）。 有时JVM可以优化您的这种开销。 但这种情况很少适用于连续的情况，
而不是平行的情况。 另一方面，我们期望工具将会发展，以帮助用户做出更好的决策。

2. 如果我对参数（F，N，Q，S）的知识太少，如何做出好的决定？

这也类似于常见的顺序编程问题。 例如，如果S是HashSet，则调用Collection方法S.contains（x）通常很快，如果是LinkedList，则为慢，否则为中间。 
通常，处理这种情况的最佳方法是使用集合不直接导出它的组件的作者，而是基于它导出操作。 用户然后与这些决定隔离。 并行操作也是一样。 
例如，具有内部Collection “price”的组件可以定义使用大小阈值的方法，除非每个元素的计算是昂贵的。 例如：

```java
public long getMaxPrice() { return priceStream().max(); }

private Stream priceStream() {
 return (prices.size() < MIN_PAR) ? prices.stream() : prices.parallelStream();
}
```

您可以通过各种方式扩展这一想法，来确定何时使用并行处理。

3. 如果我的函数需要操作IO或进行同步呢？

一个极端情况是没有使用独立标准的功能，包括本质上顺序的IO，对锁定的同步资源的访问，以及执行IO的一个并行子任务中的故障对其他方面具有副作用的情况。 
并行化这些并不太有意义。 另一方面是执行偶尔暂时的IO或同步的计算，很少阻止（例如大多数形式的日志记录和大多数并发集合的使用，如ConcurrentHashMap）。 
这些都是无害的。 中间案件需要最多的判断。 如果每个子任务可能被阻塞等待IO或访问的重要时间，则CPU资源可能会闲置，而无需任何方式使程序或JVM使用它们。 
每个人都不开心 在这些情况下，并行流通常不是一个很好的选择，但可以使用很好的替代方案，例如async-IO和CompletableFuture设计。

4. 如果我的资源是基于IO的呢？

目前，基于JDK IO的Stream源（例如BufferedReader.lines（））主要用于顺序使用，一到一个处理元素。 存在用于支持缓冲IO的高效批量处理的机会，
但是目前需要定制开发Stream源，Spliterator或Collector。 未来的JDK版本可能会支持一些常见的形式。

5. 如果我的程序在繁忙的计算机上运行，​​所有的内核都被使用吗？

机器通常只有一组固定的内核，并且在执行并行操作时不能神奇地创建更多的内核。 但是，只要选择并行执行的标准得到明确的满足，通常不会有任何理由担心。
您的并行任务将与其他人竞争CPU时间，因此您的加速速度将会降低。 在大多数情况下，这比替代品还要高效。 底层机制的设计使得如果没有其他核心可用，
与顺序性能相比，您将看到只有一个小的减速，除非系统已经过载，以致花费所有的时间上下文切换而不是做任何真正的工作，或者是 调整假设所有处理都是顺序的。 
如果您使用这样的系统，管理员可能已经禁用了多个线程/内核的使用，作为JVM配置的一部分。 如果您是这样一个系统的管理员，您可以考虑这样做。

6. 在并发模式下，是否所有的操作都是并发的？

是的，至少在某种程度上，尽管Stream框架在选择如何做到这一点的时候遵守来源和方法的限制。 一般来说，较少的约束使更多的潜在的并行性。
另一方面，不能保证框架将提取并应用所有可能的并行机会。 在某些情况下，如果您有时间和专业知识，您可以手工制作更好的并行解决方案。

7. 我会得到多少并行加速？

如果你遵循这些准则，通常足以是值得的。 可预测性不是现代硬件和系统的强项，所以一般的答案是不可能的。 缓存位置，垃圾收集率，JIT编译，内存争用，
数据布局，操作系统调度策略以及虚拟机管理程序的存在都是可以产生重大影响的因素。 这些也在顺序性能中发挥作用，但是在并行设置中经常会被放大：
连续执行导致10％差异的问题可能会导致十个并行差异。

流框架包括一些可以帮助您提高加速机会的设施。 例如，像IntStream这样的原语使用特殊化通常比顺序具有更大的并行效应，因为它不仅减少了开销（和占位面积），
而且还增强了缓存局部性。 并且使用ConcurrentHashMap而不是HashMap作为并行“收集”操作的目标可以减少内部开销。 随着人们获得框架的经验，将会出现进一步的提示和指导。

8. 这太可怕了！我们不应该仅仅使用JVM属性来禁用并行性的策略？

我们不会告诉你该怎么办。为程序员介绍新的方法来而做错事可能是可怕的。 在进行编码，设计和判断时肯定会发生错误。 但一些人已经预测几十年来, 启用应用程序级并行将导致无法实现的重大灾难。